<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>intro.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <link rel='stylesheet' href='https://unpkg.com/normalize.css/'>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/pietroppeter/nimib/assets/atom-one-light.css'>
  </head>
<body>
<header>
<div id="header-box">
<span id="home"><a href=".">üè°</a></span>
<span id="header-title"><code>intro.nim</code></span>
<span id="github"><a href="https://github.com/ajusa/binarylang-fun"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1.2em" height="1.2em" style="vertical-align: middle;" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59c.4.07.55-.17.55-.38c0-.19-.01-.82-.01-1.49c-2.01.37-2.53-.49-2.69-.94c-.09-.23-.48-.94-.82-1.13c-.28-.15-.68-.52-.01-.53c.63-.01 1.08.58 1.23.82c.72 1.21 1.87.87 2.33.66c.07-.52.28-.87.51-1.07c-1.78-.2-3.64-.89-3.64-3.95c0-.87.31-1.59.82-2.15c-.08-.2-.36-1.02.08-2.12c0 0 .67-.21 2.2.82c.64-.18 1.32-.27 2-.27c.68 0 1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82c.44 1.1.16 1.92.08 2.12c.51.56.82 1.27.82 2.15c0 3.07-1.87 3.75-3.65 3.95c.29.25.54.73.54 1.48c0 1.07-.01 1.93-.01 2.2c0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z" fill="#000"></path></svg></a></span>
</div>
<style>
div#header-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
</style>
<hr>
</header>
<main>
<h2>Introduction to Binarylang</h2>
<p>So one day, I'm working on a project and I realize that I need to do some socket level HTTP
request sending and receiving. Since this is at the socket level, I can't really use the code that is
a part of the standard library as easily, since parsing HTTP stuff is baked into other functions.</p>
<p>So, I'm given a response that looks a little something like this:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">echo</span> msg</code></pre>
<pre><samp>HTTP/1.1 404 Not Found
Date: Sun, 18 Oct 2012 10:36:20 GMT
Server: Apache/2.2.14 (Win32)
Content-Length: 11
Connection: Closed
Content-Type: text/html; charset=iso-8859-1

here is me</samp></pre>
<p>Now there are quite a few ways to parse this. Regex is probably a pretty good cross language
way of handling it, although then you'll have <a href="https://blog.codinghorror.com/regular-expressions-now-you-have-two-problems/">two problems instead of one.</a>
Nim's <code>scanf</code> module would also probably handle this pretty well, as would some sort
of generic parser using <code>parseutils</code> or <code>npeg</code>.</p>
<p>However, none of these tools really address an important issue: how do I serialize the object?</p>
<p>If I want to be able to both parse the HTTP header from a server, and create one as a client,
shouldn't that code be pretty much identical? Nim has strong meta-programming capabilities,
why can't I just define what my format looks like and have a parser/serializer generated from that?</p>
<p>Enter <a href="https://github.com/sealmove/binarylang">binarylang</a>.</p>
<p>Now, I can <em>declare</em> what my type looks like, and let it generate everything else for me. Let's try parsing just
the first line in that HTTP header, shall we?</p>
<pre><code class="nim hljs">createParser(http):
    s: _ = <span class="hljs-string">&quot;HTTP/&quot;</span>
    s: version
    s: _ = <span class="hljs-string">&quot; &quot;</span>
    s: code
    s: _ = <span class="hljs-string">&quot; &quot;</span>
    s: msg
    s: _ = <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>
<span class="hljs-keyword">var</span> sbs = newStringBitStream(msg)
print toHTTP(msg)</code></pre>
<pre><samp>toHttp(msg)=Http(version:"1.1", code:"404", msg:"Not Found")</samp></pre>
<p>So what's going on here? First, we tell binarylang to go ahead and create a type called http, for parsing.
Next, we use it to define the format of a header. A header has a string, that starts with HTTP/, and then a version.
The version is also a string, so we prefix it with a <code>s</code>. Then, we look for a space to separate the two, and continue on
in a similar fashion. Here, everything we are parsing happens to behave like a string, so we can have all the types be string.
An underscore (_) simply signifies that we don't care enough about that value to name it. It is good for what are called
&quot;magic&quot; values, or to skip to the field you actually care about.</p>
<p>Since binarylang operates on bitstreams, we turn the string into one, and then tell it to parse into an object.</p>
<p>So, we have a functioning parser for the example header. What do we do if we wanted to generate a header though?</p>
<pre><code class="nim hljs"><span class="hljs-keyword">var</span> header = <span class="hljs-type">HTTP</span>(version: <span class="hljs-string">&quot;1.1&quot;</span>, code: <span class="hljs-string">&quot;200&quot;</span>, msg: <span class="hljs-string">&quot;OK&quot;</span>)
<span class="hljs-keyword">echo</span> header.fromHTTP</code></pre>
<pre><samp>HTTP/1.1 200 OK</samp></pre>
<p>Wow. It pretty much just works.</p>
<p>Next are the headers. While we could proceed as we did earlier, for each of the headers, it won't quite work.
HTTP headers can be in a different order, and more importantly, they can be <em>anything</em>. So, we need some way to parse
a sequence of headers. First, let's define a type for the header itself.</p>
<pre><code class="nim hljs">createParser(header):
    s: name
    s: _ = <span class="hljs-string">&quot;: &quot;</span>
    s: value
    s: _ = <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>
print <span class="hljs-string">&quot;Server: Apache/2.2.14 (Win32)</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>.toHeader</code></pre>
<pre><samp>toHeader("Server: Apache/2.2.14 (Win32)\n")=Header(name:"Server", value:"Apache/2.2.14 (Win32)")</samp></pre>
<p>Fantastic! We now have a way to parse a single header line. Of course, we need to handle a list of these
somehow. Thankfully, binarylang has us covered.</p>
<pre><code class="nim hljs">createParser(http2):
    s: _ = <span class="hljs-string">&quot;HTTP/&quot;</span>
    s: version
    s: _ = <span class="hljs-string">&quot; &quot;</span>
    s: code
    s: _ = <span class="hljs-string">&quot; &quot;</span>
    s: msg
    s: _ = <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>
    *header: {headers}
    s: _ = <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>
print msg.toHTTP2</code></pre>
<pre><samp>toHttp2(msg)=Http2(
  version:"1.1",
  code:"404",
  msg:"Not Found",
  headers:@[
    Header(name:"Date", value:"Sun, 18 Oct 2012 10:36:20 GMT"),
    Header(name:"Server", value:"Apache/2.2.14 (Win32)"),
    Header(name:"Content-Length", value:"11"),
    Header(name:"Connection", value:"Closed"),
    Header(name:"Content-Type", value:"text/html; charset=iso-8859-1")
  ]
)</samp></pre>
<p>Hold on, what's going on here? What's up with all of the weird * and {}? Doesn't * mean a
public property in Nim?</p>
<p>The * can be used for two different things in binarylang. It can be used to either make a field public,
or to refer to an existing parser being used as a type. In this case, we can use it to refer to the header
type that we defined earlier. As for the <code>{headers}</code>, the curly braces denote &quot;read into a seq until the next value can be parsed&quot;.
So, what happens is that we try to parse each header, and after parsing each one we see if the next thing on the stream is a
newline. If it is, we stop parsing headers and finish, otherwise we keep adding on to that seq. Since HTTP headers use newlines
to delimit the different sections, this works out fine.</p>

</main>
<footer>
<hr>
<span id="made">made with <a href="https://github.com/pietroppeter/nimib">nimib üê≥</a></span>
<button id="show" onclick="toggleSourceDisplay()">Show Source</button>
<section id="source">
<pre><code class="nim hljs"><span class="hljs-keyword">import</span> binarylang, sequtils, strutils, print, json
printColors = <span class="hljs-literal">false</span>
<span class="hljs-keyword">import</span> nimib
nbInit
nbText: <span class="hljs-string">&quot;&quot;&quot;
## Introduction to Binarylang
So one day, I'm working on a project and I realize that I need to do some socket level HTTP
request sending and receiving. Since this is at the socket level, I can't really use the code that is
a part of the standard library as easily, since parsing HTTP stuff is baked into other functions.

So, I'm given a response that looks a little something like this:
&quot;&quot;&quot;</span>

<span class="hljs-keyword">var</span> msg = <span class="hljs-string">&quot;&quot;&quot;
HTTP/1.1 404 Not Found
Date: Sun, 18 Oct 2012 10:36:20 GMT
Server: Apache/2.2.14 (Win32)
Content-Length: 11
Connection: Closed
Content-Type: text/html; charset=iso-8859-1

here is me
&quot;&quot;&quot;</span>
nbCode:
    <span class="hljs-keyword">echo</span> msg

nbText: <span class="hljs-string">&quot;&quot;&quot;
Now there are quite a few ways to parse this. Regex is probably a pretty good cross language
way of handling it, although then you'll have [two problems instead of one.](https://blog.codinghorror.com/regular-expressions-now-you-have-two-problems/)
Nim's `scanf` module would also probably handle this pretty well, as would some sort
of generic parser using `parseutils` or `npeg`.

However, none of these tools really address an important issue: how do I serialize the object?

If I want to be able to both parse the HTTP header from a server, and create one as a client,
shouldn't that code be pretty much identical? Nim has strong meta-programming capabilities,
why can't I just define what my format looks like and have a parser/serializer generated from that?

Enter [binarylang](https://github.com/sealmove/binarylang).

Now, I can *declare* what my type looks like, and let it generate everything else for me. Let's try parsing just
the first line in that HTTP header, shall we?
&quot;&quot;&quot;</span>
<span class="hljs-keyword">block</span>:
    nbCode:
        createParser(http):
            s: _ = <span class="hljs-string">&quot;HTTP/&quot;</span>
            s: version
            s: _ = <span class="hljs-string">&quot; &quot;</span>
            s: code
            s: _ = <span class="hljs-string">&quot; &quot;</span>
            s: msg
            s: _ = <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>
        <span class="hljs-keyword">var</span> sbs = newStringBitStream(msg)
        print toHTTP(msg)

    nbText: <span class="hljs-string">&quot;&quot;&quot;
So what's going on here? First, we tell binarylang to go ahead and create a type called http, for parsing.
Next, we use it to define the format of a header. A header has a string, that starts with HTTP/, and then a version.
The version is also a string, so we prefix it with a `s`. Then, we look for a space to separate the two, and continue on
in a similar fashion. Here, everything we are parsing happens to behave like a string, so we can have all the types be string.
An underscore (_) simply signifies that we don't care enough about that value to name it. It is good for what are called
&quot;magic&quot; values, or to skip to the field you actually care about.

Since binarylang operates on bitstreams, we turn the string into one, and then tell it to parse into an object.

So, we have a functioning parser for the example header. What do we do if we wanted to generate a header though?
    &quot;&quot;&quot;</span>

    nbCode:
        <span class="hljs-keyword">var</span> header = <span class="hljs-type">HTTP</span>(version: <span class="hljs-string">&quot;1.1&quot;</span>, code: <span class="hljs-string">&quot;200&quot;</span>, msg: <span class="hljs-string">&quot;OK&quot;</span>)
        <span class="hljs-keyword">echo</span> header.fromHTTP
    nbText: <span class="hljs-string">&quot;&quot;&quot;Wow. It pretty much just works.&quot;&quot;&quot;</span>
<span class="hljs-keyword">block</span>:
    nbText: <span class="hljs-string">&quot;&quot;&quot;
    Next are the headers. While we could proceed as we did earlier, for each of the headers, it won't quite work.
    HTTP headers can be in a different order, and more importantly, they can be *anything*. So, we need some way to parse
    a sequence of headers. First, let's define a type for the header itself.
    &quot;&quot;&quot;</span>
    nbCode:
        createParser(header):
            s: name
            s: _ = <span class="hljs-string">&quot;: &quot;</span>
            s: value
            s: _ = <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>
        print <span class="hljs-string">&quot;Server: Apache/2.2.14 (Win32)</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>.toHeader
    nbText: <span class="hljs-string">&quot;&quot;&quot;
    Fantastic! We now have a way to parse a single header line. Of course, we need to handle a list of these
    somehow. Thankfully, binarylang has us covered.
    &quot;&quot;&quot;</span>
    nbCode:
        createParser(http2):
            s: _ = <span class="hljs-string">&quot;HTTP/&quot;</span>
            s: version
            s: _ = <span class="hljs-string">&quot; &quot;</span>
            s: code
            s: _ = <span class="hljs-string">&quot; &quot;</span>
            s: msg
            s: _ = <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>
            *header: {headers}
            s: _ = <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>
        print msg.toHTTP2
    nbText: <span class="hljs-string">&quot;&quot;&quot;
Hold on, what's going on here? What's up with all of the weird * and {}? Doesn't * mean a 
public property in Nim?

The * can be used for two different things in binarylang. It can be used to either make a field public,
or to refer to an existing parser being used as a type. In this case, we can use it to refer to the header
type that we defined earlier. As for the `{headers}`, the curly braces denote &quot;read into a seq until the next value can be parsed&quot;. 
So, what happens is that we try to parse each header, and after parsing each one we see if the next thing on the stream is a
newline. If it is, we stop parsing headers and finish, otherwise we keep adding on to that seq. Since HTTP headers use newlines
to delimit the different sections, this works out fine.
    &quot;&quot;&quot;</span>
<span class="hljs-comment"># var sbs = newStringBitStream(msg)</span>
<span class="hljs-comment"># var data = HTTP.get(sbs)</span>
<span class="hljs-comment"># echo data.code + 10</span>
<span class="hljs-comment"># var gen: typeGetter(HTTP)</span>
<span class="hljs-comment"># gen.body = &quot;asdfasdfasdf&quot;</span>
<span class="hljs-comment"># var content: typeGetter(Header) = (&quot;Content-Length&quot;, &quot;10&quot;)</span>
<span class="hljs-comment"># gen.version = &quot;1.1&quot;</span>
<span class="hljs-comment"># gen.headers.add(content)</span>
<span class="hljs-comment"># var gensbs = newStringBitStream()</span>
<span class="hljs-comment"># HTTP.put(gensbs, gen)</span>
<span class="hljs-comment"># gensbs.seek(0)</span>
<span class="hljs-comment"># echo gensbs.readAll</span>

<span class="hljs-comment"># var test = &quot;&quot;&quot;</span>
<span class="hljs-comment"># &lt;html&gt;</span>
<span class="hljs-comment"># &lt;body&gt;</span>

<span class="hljs-comment"># &lt;h1&gt;My First Heading&lt;/h1&gt;</span>

<span class="hljs-comment"># &lt;p&gt;My first paragraph.&lt;/p&gt;</span>

<span class="hljs-comment"># &lt;/body&gt;</span>
<span class="hljs-comment"># &lt;/html&gt;</span>
<span class="hljs-comment"># &quot;&quot;&quot;.newStringBitStream</span>
<span class="hljs-comment"># # var test = &quot;&quot;&quot;</span>
<span class="hljs-comment"># # &lt;h1&gt;My First Heading&lt;/h1&gt;</span>
<span class="hljs-comment"># # &quot;&quot;&quot;.newStringBitStream</span>
<span class="hljs-comment"># template condGet(field, parse, cond: untyped) =</span>
<span class="hljs-comment">#   if cond:</span>
<span class="hljs-comment">#       parse</span>
<span class="hljs-comment"># template condPut(field, encode, cond: untyped) =</span>
<span class="hljs-comment">#   if cond:</span>
<span class="hljs-comment">#       encode</span>
<span class="hljs-comment"># proc stop(s: Bitstream): bool =</span>
<span class="hljs-comment">#     var pos = s.getPosition</span>
<span class="hljs-comment">#     var ch = s.readStr(8)</span>
<span class="hljs-comment">#     result = ch != &quot;/&quot;</span>
<span class="hljs-comment">#     s.setPosition(pos)</span>

<span class="hljs-comment"># createParser(html):</span>
<span class="hljs-comment">#     s: text</span>
<span class="hljs-comment">#     s: _ = &quot;&lt;&quot;</span>
<span class="hljs-comment">#     s {cond: s.stop}: tag</span>
<span class="hljs-comment">#     s {cond: s.stop}: _ = &quot;&gt;&quot;</span>
<span class="hljs-comment">#     *html {cond: s.stop}: {children}</span>
<span class="hljs-comment">#     s {cond: s.stop}: _ = &quot;/&quot;</span>

<span class="hljs-comment"># var output = html.get(test)</span>
<span class="hljs-comment"># print output</span>
<span class="hljs-comment"># echo pretty %output</span>
<span class="hljs-comment"># createParser(Header):</span>
<span class="hljs-comment">#     s: name</span>
<span class="hljs-comment">#     s: _ = &quot;: &quot;</span>
<span class="hljs-comment">#     s: value</span>
<span class="hljs-comment">#     s: _ = &quot;\n&quot;</span>
<span class="hljs-comment"># createParser(HTTP):</span>
<span class="hljs-comment">#     s: _ = &quot;HTTP/&quot;</span>
<span class="hljs-comment">#     s: version</span>
<span class="hljs-comment">#     s: _ = &quot; &quot;</span>
<span class="hljs-comment">#     s {@get: _.parseInt, @set: $_}: code</span>
<span class="hljs-comment">#     s: _ = &quot; &quot;</span>
<span class="hljs-comment">#     s: msg</span>
<span class="hljs-comment">#     s: _ = &quot;\n&quot;</span>
<span class="hljs-comment">#     *Header: {headers}</span>
<span class="hljs-comment">#     s: _ = &quot;\n&quot;</span>
<span class="hljs-comment">#     s: body(headers.filterIt(it.name == &quot;Content-Length&quot;)[0].value.parseInt)</span>

<span class="hljs-comment"># var sbs = newStringBitStream(msg)</span>
<span class="hljs-comment"># var data = HTTP.get(sbs)</span>
<span class="hljs-comment"># echo data.code + 10</span>
<span class="hljs-comment"># var gen: typeGetter(HTTP)</span>
<span class="hljs-comment"># gen.body = &quot;asdfasdfasdf&quot;</span>
<span class="hljs-comment"># var content: typeGetter(Header) = (&quot;Content-Length&quot;, &quot;10&quot;)</span>
<span class="hljs-comment"># gen.version = &quot;1.1&quot;</span>
<span class="hljs-comment"># gen.headers.add(content)</span>
<span class="hljs-comment"># var gensbs = newStringBitStream()</span>
<span class="hljs-comment"># HTTP.put(gensbs, gen)</span>
<span class="hljs-comment"># gensbs.seek(0)</span>
<span class="hljs-comment"># echo gensbs.readAll</span>

<span class="hljs-comment"># var test = &quot;&quot;&quot;</span>
<span class="hljs-comment"># &lt;html&gt;</span>
<span class="hljs-comment"># &lt;body&gt;</span>

<span class="hljs-comment"># &lt;h1&gt;My First Heading&lt;/h1&gt;</span>

<span class="hljs-comment"># &lt;p&gt;My first paragraph.&lt;/p&gt;</span>

<span class="hljs-comment"># &lt;/body&gt;</span>
<span class="hljs-comment"># &lt;/html&gt;</span>
<span class="hljs-comment"># &quot;&quot;&quot;.newStringBitStream</span>
<span class="hljs-comment"># # var test = &quot;&quot;&quot;</span>
<span class="hljs-comment"># # &lt;h1&gt;My First Heading&lt;/h1&gt;</span>
<span class="hljs-comment"># # &quot;&quot;&quot;.newStringBitStream</span>
<span class="hljs-comment"># template condGet(field, parse, cond: untyped) =</span>
<span class="hljs-comment">#   if cond:</span>
<span class="hljs-comment">#       parse</span>
<span class="hljs-comment"># template condPut(field, encode, cond: untyped) =</span>
<span class="hljs-comment">#   if cond:</span>
<span class="hljs-comment">#       encode</span>
<span class="hljs-comment"># proc stop(s: Bitstream): bool =</span>
<span class="hljs-comment">#     var pos = s.getPosition</span>
<span class="hljs-comment">#     var ch = s.readStr(8)</span>
<span class="hljs-comment">#     result = ch != &quot;/&quot;</span>
<span class="hljs-comment">#     s.setPosition(pos)</span>

<span class="hljs-comment"># createParser(html):</span>
<span class="hljs-comment">#     s: text</span>
<span class="hljs-comment">#     s: _ = &quot;&lt;&quot;</span>
<span class="hljs-comment">#     s {cond: s.stop}: tag</span>
<span class="hljs-comment">#     s {cond: s.stop}: _ = &quot;&gt;&quot;</span>
<span class="hljs-comment">#     *html {cond: s.stop}: {children}</span>
<span class="hljs-comment">#     s {cond: s.stop}: _ = &quot;/&quot;</span>

<span class="hljs-comment"># var output = html.get(test)</span>
<span class="hljs-comment"># print output</span>
<span class="hljs-comment"># echo pretty %output</span>
nbShow
</code></pre>
</section>
<script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script>
<style>
span#made {
  font-size: 0.8rem;
}
button#show {
  font-size: 0.8rem;
}

button#show {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}
</style>
</footer>
</body>
</html>